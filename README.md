# Overview
This repository contains the code generated when solving a product allocation problem for an automated order picking system in a pharmaceutical warehouse. 
The problem was part of my Master's thesis in Logistics Management and Computer Science at Link√∂ping University. 
The full report can be read in `thesis.pdf`. In the report a detailed description of the problem, the aim of the thesis, the methodology, results and the conclusions are presented.
For the curious reader please read the thesis. There will be short summary of the work in this readme. 

# The problem
Apotea AB, Sweden's largest online pharmacy, had bought an A-frame.
An A-frame is an automatic order picking system, where products are dispensed onto a conveyor belt
and then put in a box. [Here](https://www.youtube.com/watch?v=TFJieI9ZwpM) is a video of an A-frame in action.
The A-frame that Apotea bought had a capacity of 1500 different products. Apotea has a large number of products, around 18000. 
This meant that the possible combinations to test would be (18000 choose 1500) which is around 10^2240 different combinations.
It is unfeasible to test each combination, instead some algorithm should be used. 

# The approach
The study started with creating an simulation of the A-frame, to correctly evaluate different allocations.
The simulation was created using simpy and be seen in `code/simulation/aframesimulation.py`.

With a simulation created the study tested three different approaches for product allocation.

First all the products were ranked by their quantities sold which resulted in an automation level (the number of orders picked by the A-frame divided by the number of total orders picked in the warehouse) of 29.9%.

The second method was similar, it ranked all products by their quantities sold but removed all orders where an at least one product was determined to not be able to fit in the A-frame. The automation level for this was 31.37%

The third method used association rule learning, which is a machine learning technique to find products that are frequently bought together. 
The rules were placed in a graph structure and then solved using a heuristic. This resulted in an automation level of 31.57%. 

# The code
The code has mixed documentation. The main purpose of this code was to accomplish this thesis. Its purpose has never been to be used in a production environment. 
I choose to publish the code on github for the interested reader. I will not maintain or extend any of the code. In case an interested reader has questions about any code, please raise an Issue in the Issue tracker and tag me. 

## allocation
`generate_selection_from_quant_only_all_skus.py` generates an allocation using all orders.

`generate_selection_from_quant_only_ok_skus.py` generates an allocation using only valid orders.

`greedy_graph_search.py` places the association rules in a graph structure, then solves it using a heuristic. 

`change_support.py` changes the minimum support for the generated rules.

`draw_graph.py` draws the generated association rules as a graph structure.

## data_analysis
`orders.py` takes in raw data and generates 
the training and testing data sets used for the rest of the thesis. 

`orders_for_date.py` splits the data generated by `orders.py` into days to be used in the simulation.

`sku_in_channel.py` finds how many products can fit in one channel. 

`article_dimensions.py` takes a generated aframe allocation 
and merges the information from the `sku_in_channel.py` to get a data file that can be used in the simulation.

`find_max_automation_level.py` calculates the maximum automation level assuming the A-frame has an infinite capacity. 

`count_sku_support_all_skus.py` counts the support for the products that can fit in the A-frame using all orders.

`count_skus_support.py` counts the support for the products that can fit in the A-frame using only valid orders. 

`count_sku_quantity_per_day.py` counts which products overflowed their channel.

`test_normality_for_skus.py` performs a normality test on each product. 

`sku_in_channel.py` assigns the number of channels for a product using either the mean demand or the median demand. 

`aframe_over_time.py` plots the resulting data from the simulation to different figures. 

## machine_learning
`association_rules.py` performs the FP-growth algorithm on the data set. 

`clean_rules.py` cleans the rules generated by FP-growth. 

## simulation 
`aframesimulation.py` this is the simulation class. It is a big file and is heavily documented. Please read the documentation in the file. 

`aframe_sim_by_day` this performs a simulation of each day examined in the study.



# License
This code is available under the gplv3 license. The copyright of the code is held by me, Alexander Dahl. It is not permitted to sell my code. 
